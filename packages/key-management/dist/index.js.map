{"version":3,"sources":["../src/chains/starknet/types.ts","../../../node_modules/@noble/curves/src/abstract/utils.ts","../src/chains/starknet/key-derivation.ts","../src/errors/AuthenticationError.ts","../src/errors/InvalidMnemonicError.ts","../src/errors/TxSigningError.ts","../src/InMemoryKeyAgent.ts","../src/KeyAgentBase.ts","../src/emip3.ts","../src/KeyDecryptor.ts","../src/chains/starknet/credential-derivation.ts","../src/chains/starknet/signing-operations.ts","../src/chains/starknet/stealth-derivation.ts","../src/types.ts","../src/util/bip39.ts"],"sourcesContent":["import type {\n  Call,\n  DeployAccountSignerDetails,\n  Signature,\n  TypedData,\n} from \"starknet\"\n\nexport type StarknetDerivationArgs = {\n  accountIndex: number\n  addressIndex: number\n}\n\nexport type StarknetKeyPair = {\n  spendingKeyPair: { privateSpendingKey: string; publicSpendingKey: string }\n  viewingKeyPair: { privateViewingKey: string; publicViewingKey: string }\n}\n\nexport enum StarknetKeyConst {\n  /**\n   * Constant value used for defining the purpose in a BIP44 path\n   */\n  PURPOSE = 44,\n\n  /**\n   * COIN_TYPE value for Starknet\n   */\n  STARKNET_COIN_TYPE = 9004,\n}\n\nexport type StarknetGroupedCredentials = {\n  \"@context\": [\"https://w3id.org/wallet/v1\"]\n  id: string\n  type: \"Starknet\"\n  controller: string\n  name: string\n  description: string\n  addressIndex: number\n  accountIndex: number\n  spendingKey: {\n    publicSpendingKey: string\n    encryptedPrivateKeyBytes: Uint8Array\n  }\n  viewingKey: {\n    publicViewingKey: string\n    encryptedPrivateKeyBytes: Uint8Array\n  }\n}\n\nexport type SignablePayload =\n  | string\n  | Uint8Array\n  | TypedData\n  | Call[]\n  | DeployAccountSignerDetails\n\nexport type SignatureResult = Signature\n","/**\n * Hex, bytes and number utilities.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\n// 100 lines of code in the file are duplicated from noble-hashes (utils).\n// This is OK: `abstract` directory does not use noble-hashes.\n// User may opt-in into using different hashing library. This way, noble-hashes\n// won't be included into their bundle.\nconst _0n = /* @__PURE__ */ BigInt(0);\nconst _1n = /* @__PURE__ */ BigInt(1);\nexport type Hex = Uint8Array | string; // hex strings are accepted for simplicity\nexport type PrivKey = Hex | bigint; // bigints are accepted to ease learning curve\nexport type CHash = {\n  (message: Uint8Array | string): Uint8Array;\n  blockLen: number;\n  outputLen: number;\n  create(opts?: { dkLen?: number }): any; // For shake\n};\nexport type FHash = (message: Uint8Array | string) => Uint8Array;\n\nexport function isBytes(a: unknown): a is Uint8Array {\n  return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\n\nexport function abytes(item: unknown): void {\n  if (!isBytes(item)) throw new Error('Uint8Array expected');\n}\n\nexport function abool(title: string, value: boolean): void {\n  if (typeof value !== 'boolean') throw new Error(title + ' boolean expected, got ' + value);\n}\n\n// Used in weierstrass, der\nexport function numberToHexUnpadded(num: number | bigint): string {\n  const hex = num.toString(16);\n  return hex.length & 1 ? '0' + hex : hex;\n}\n\nexport function hexToNumber(hex: string): bigint {\n  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n  return hex === '' ? _0n : BigInt('0x' + hex); // Big Endian\n}\n\n// Built-in hex conversion https://caniuse.com/mdn-javascript_builtins_uint8array_fromhex\nconst hasHexBuiltin: boolean =\n  // @ts-ignore\n  typeof Uint8Array.from([]).toHex === 'function' && typeof Uint8Array.fromHex === 'function';\n\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) =>\n  i.toString(16).padStart(2, '0')\n);\n\n/**\n * Convert byte array to hex string. Uses built-in function, when available.\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nexport function bytesToHex(bytes: Uint8Array): string {\n  abytes(bytes);\n  // @ts-ignore\n  if (hasHexBuiltin) return bytes.toHex();\n  // pre-caching improves the speed 6x\n  let hex = '';\n  for (let i = 0; i < bytes.length; i++) {\n    hex += hexes[bytes[i]];\n  }\n  return hex;\n}\n\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 } as const;\nfunction asciiToBase16(ch: number): number | undefined {\n  if (ch >= asciis._0 && ch <= asciis._9) return ch - asciis._0; // '2' => 50-48\n  if (ch >= asciis.A && ch <= asciis.F) return ch - (asciis.A - 10); // 'B' => 66-(65-10)\n  if (ch >= asciis.a && ch <= asciis.f) return ch - (asciis.a - 10); // 'b' => 98-(97-10)\n  return;\n}\n\n/**\n * Convert hex string to byte array. Uses built-in function, when available.\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nexport function hexToBytes(hex: string): Uint8Array {\n  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n  // @ts-ignore\n  if (hasHexBuiltin) return Uint8Array.fromHex(hex);\n  const hl = hex.length;\n  const al = hl / 2;\n  if (hl % 2) throw new Error('hex string expected, got unpadded hex of length ' + hl);\n  const array = new Uint8Array(al);\n  for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n    const n1 = asciiToBase16(hex.charCodeAt(hi));\n    const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n    if (n1 === undefined || n2 === undefined) {\n      const char = hex[hi] + hex[hi + 1];\n      throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n    }\n    array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163\n  }\n  return array;\n}\n\n// BE: Big Endian, LE: Little Endian\nexport function bytesToNumberBE(bytes: Uint8Array): bigint {\n  return hexToNumber(bytesToHex(bytes));\n}\nexport function bytesToNumberLE(bytes: Uint8Array): bigint {\n  abytes(bytes);\n  return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));\n}\n\nexport function numberToBytesBE(n: number | bigint, len: number): Uint8Array {\n  return hexToBytes(n.toString(16).padStart(len * 2, '0'));\n}\nexport function numberToBytesLE(n: number | bigint, len: number): Uint8Array {\n  return numberToBytesBE(n, len).reverse();\n}\n// Unpadded, rarely used\nexport function numberToVarBytesBE(n: number | bigint): Uint8Array {\n  return hexToBytes(numberToHexUnpadded(n));\n}\n\n/**\n * Takes hex string or Uint8Array, converts to Uint8Array.\n * Validates output length.\n * Will throw error for other types.\n * @param title descriptive title for an error e.g. 'private key'\n * @param hex hex string or Uint8Array\n * @param expectedLength optional, will compare to result array's length\n * @returns\n */\nexport function ensureBytes(title: string, hex: Hex, expectedLength?: number): Uint8Array {\n  let res: Uint8Array;\n  if (typeof hex === 'string') {\n    try {\n      res = hexToBytes(hex);\n    } catch (e) {\n      throw new Error(title + ' must be hex string or Uint8Array, cause: ' + e);\n    }\n  } else if (isBytes(hex)) {\n    // Uint8Array.from() instead of hash.slice() because node.js Buffer\n    // is instance of Uint8Array, and its slice() creates **mutable** copy\n    res = Uint8Array.from(hex);\n  } else {\n    throw new Error(title + ' must be hex string or Uint8Array');\n  }\n  const len = res.length;\n  if (typeof expectedLength === 'number' && len !== expectedLength)\n    throw new Error(title + ' of length ' + expectedLength + ' expected, got ' + len);\n  return res;\n}\n\n/**\n * Copies several Uint8Arrays into one.\n */\nexport function concatBytes(...arrays: Uint8Array[]): Uint8Array {\n  let sum = 0;\n  for (let i = 0; i < arrays.length; i++) {\n    const a = arrays[i];\n    abytes(a);\n    sum += a.length;\n  }\n  const res = new Uint8Array(sum);\n  for (let i = 0, pad = 0; i < arrays.length; i++) {\n    const a = arrays[i];\n    res.set(a, pad);\n    pad += a.length;\n  }\n  return res;\n}\n\n// Compares 2 u8a-s in kinda constant time\nexport function equalBytes(a: Uint8Array, b: Uint8Array): boolean {\n  if (a.length !== b.length) return false;\n  let diff = 0;\n  for (let i = 0; i < a.length; i++) diff |= a[i] ^ b[i];\n  return diff === 0;\n}\n\n// Global symbols in both browsers and Node.js since v11\n// See https://github.com/microsoft/TypeScript/issues/31535\ndeclare const TextEncoder: any;\n\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nexport function utf8ToBytes(str: string): Uint8Array {\n  if (typeof str !== 'string') throw new Error('string expected');\n  return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n\n// Is positive bigint\nconst isPosBig = (n: bigint) => typeof n === 'bigint' && _0n <= n;\n\nexport function inRange(n: bigint, min: bigint, max: bigint): boolean {\n  return isPosBig(n) && isPosBig(min) && isPosBig(max) && min <= n && n < max;\n}\n\n/**\n * Asserts min <= n < max. NOTE: It's < max and not <= max.\n * @example\n * aInRange('x', x, 1n, 256n); // would assume x is in (1n..255n)\n */\nexport function aInRange(title: string, n: bigint, min: bigint, max: bigint): void {\n  // Why min <= n < max and not a (min < n < max) OR b (min <= n <= max)?\n  // consider P=256n, min=0n, max=P\n  // - a for min=0 would require -1:          `inRange('x', x, -1n, P)`\n  // - b would commonly require subtraction:  `inRange('x', x, 0n, P - 1n)`\n  // - our way is the cleanest:               `inRange('x', x, 0n, P)\n  if (!inRange(n, min, max))\n    throw new Error('expected valid ' + title + ': ' + min + ' <= n < ' + max + ', got ' + n);\n}\n\n// Bit operations\n\n/**\n * Calculates amount of bits in a bigint.\n * Same as `n.toString(2).length`\n * TODO: merge with nLength in modular\n */\nexport function bitLen(n: bigint): number {\n  let len;\n  for (len = 0; n > _0n; n >>= _1n, len += 1);\n  return len;\n}\n\n/**\n * Gets single bit at position.\n * NOTE: first bit position is 0 (same as arrays)\n * Same as `!!+Array.from(n.toString(2)).reverse()[pos]`\n */\nexport function bitGet(n: bigint, pos: number): bigint {\n  return (n >> BigInt(pos)) & _1n;\n}\n\n/**\n * Sets single bit at position.\n */\nexport function bitSet(n: bigint, pos: number, value: boolean): bigint {\n  return n | ((value ? _1n : _0n) << BigInt(pos));\n}\n\n/**\n * Calculate mask for N bits. Not using ** operator with bigints because of old engines.\n * Same as BigInt(`0b${Array(i).fill('1').join('')}`)\n */\nexport const bitMask = (n: number): bigint => (_1n << BigInt(n)) - _1n;\n\n// DRBG\n\nconst u8n = (len: number) => new Uint8Array(len); // creates Uint8Array\nconst u8fr = (arr: ArrayLike<number>) => Uint8Array.from(arr); // another shortcut\ntype Pred<T> = (v: Uint8Array) => T | undefined;\n/**\n * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n * @returns function that will call DRBG until 2nd arg returns something meaningful\n * @example\n *   const drbg = createHmacDRBG<Key>(32, 32, hmac);\n *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined\n */\nexport function createHmacDrbg<T>(\n  hashLen: number,\n  qByteLen: number,\n  hmacFn: (key: Uint8Array, ...messages: Uint8Array[]) => Uint8Array\n): (seed: Uint8Array, predicate: Pred<T>) => T {\n  if (typeof hashLen !== 'number' || hashLen < 2) throw new Error('hashLen must be a number');\n  if (typeof qByteLen !== 'number' || qByteLen < 2) throw new Error('qByteLen must be a number');\n  if (typeof hmacFn !== 'function') throw new Error('hmacFn must be a function');\n  // Step B, Step C: set hashLen to 8*ceil(hlen/8)\n  let v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n  let k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same\n  let i = 0; // Iterations counter, will throw when over 1000\n  const reset = () => {\n    v.fill(1);\n    k.fill(0);\n    i = 0;\n  };\n  const h = (...b: Uint8Array[]) => hmacFn(k, v, ...b); // hmac(k)(v, ...values)\n  const reseed = (seed = u8n(0)) => {\n    // HMAC-DRBG reseed() function. Steps D-G\n    k = h(u8fr([0x00]), seed); // k = hmac(k || v || 0x00 || seed)\n    v = h(); // v = hmac(k || v)\n    if (seed.length === 0) return;\n    k = h(u8fr([0x01]), seed); // k = hmac(k || v || 0x01 || seed)\n    v = h(); // v = hmac(k || v)\n  };\n  const gen = () => {\n    // HMAC-DRBG generate() function\n    if (i++ >= 1000) throw new Error('drbg: tried 1000 values');\n    let len = 0;\n    const out: Uint8Array[] = [];\n    while (len < qByteLen) {\n      v = h();\n      const sl = v.slice();\n      out.push(sl);\n      len += v.length;\n    }\n    return concatBytes(...out);\n  };\n  const genUntil = (seed: Uint8Array, pred: Pred<T>): T => {\n    reset();\n    reseed(seed); // Steps D-G\n    let res: T | undefined = undefined; // Step H: grind until k is in [1..n-1]\n    while (!(res = pred(gen()))) reseed();\n    reset();\n    return res;\n  };\n  return genUntil;\n}\n\n// Validating curves and fields\n\nconst validatorFns = {\n  bigint: (val: any): boolean => typeof val === 'bigint',\n  function: (val: any): boolean => typeof val === 'function',\n  boolean: (val: any): boolean => typeof val === 'boolean',\n  string: (val: any): boolean => typeof val === 'string',\n  stringOrUint8Array: (val: any): boolean => typeof val === 'string' || isBytes(val),\n  isSafeInteger: (val: any): boolean => Number.isSafeInteger(val),\n  array: (val: any): boolean => Array.isArray(val),\n  field: (val: any, object: any): any => (object as any).Fp.isValid(val),\n  hash: (val: any): boolean => typeof val === 'function' && Number.isSafeInteger(val.outputLen),\n} as const;\ntype Validator = keyof typeof validatorFns;\ntype ValMap<T extends Record<string, any>> = { [K in keyof T]?: Validator };\n// type Record<K extends string | number | symbol, T> = { [P in K]: T; }\n\nexport function validateObject<T extends Record<string, any>>(\n  object: T,\n  validators: ValMap<T>,\n  optValidators: ValMap<T> = {}\n): T {\n  const checkField = (fieldName: keyof T, type: Validator, isOptional: boolean) => {\n    const checkVal = validatorFns[type];\n    if (typeof checkVal !== 'function') throw new Error('invalid validator function');\n\n    const val = object[fieldName as keyof typeof object];\n    if (isOptional && val === undefined) return;\n    if (!checkVal(val, object)) {\n      throw new Error(\n        'param ' + String(fieldName) + ' is invalid. Expected ' + type + ', got ' + val\n      );\n    }\n  };\n  for (const [fieldName, type] of Object.entries(validators)) checkField(fieldName, type!, false);\n  for (const [fieldName, type] of Object.entries(optValidators)) checkField(fieldName, type!, true);\n  return object;\n}\n// validate type tests\n// const o: { a: number; b: number; c: number } = { a: 1, b: 5, c: 6 };\n// const z0 = validateObject(o, { a: 'isSafeInteger' }, { c: 'bigint' }); // Ok!\n// // Should fail type-check\n// const z1 = validateObject(o, { a: 'tmp' }, { c: 'zz' });\n// const z2 = validateObject(o, { a: 'isSafeInteger' }, { c: 'zz' });\n// const z3 = validateObject(o, { test: 'boolean', z: 'bug' });\n// const z4 = validateObject(o, { a: 'boolean', z: 'bug' });\n\n/**\n * throws not implemented error\n */\nexport const notImplemented = (): never => {\n  throw new Error('not implemented');\n};\n\n/**\n * Memoizes (caches) computation result.\n * Uses WeakMap: the value is going auto-cleaned by GC after last reference is removed.\n */\nexport function memoized<T extends object, R, O extends any[]>(\n  fn: (arg: T, ...args: O) => R\n): (arg: T, ...args: O) => R {\n  const map = new WeakMap<T, R>();\n  return (arg: T, ...args: O): R => {\n    const val = map.get(arg);\n    if (val !== undefined) return val;\n    const computed = fn(arg, ...args);\n    map.set(arg, computed);\n    return computed;\n  };\n}\n","import { type Hex, bytesToHex } from \"@noble/curves/abstract/utils\"\nimport { sha256 } from \"@noble/hashes/sha256\"\nimport { getStarkKey, grindKey as microGrindKey } from \"@scure/starknet\"\nimport { ethers } from \"ethers\"\nimport { ec, encode, hash } from \"starknet\"\nimport {\n  type StarknetDerivationArgs,\n  StarknetKeyConst,\n  type StarknetKeyPair,\n} from \"./types\"\n\n/**\n * Utility to add '0x' prefix if missing\n */\nconst { addHexPrefix } = encode\n\n/**\n * Grinds a private key to a valid Starknet private key.\n *\n * Starknet requires private keys to be < curve order, so we \"grind\"\n * the raw 256-bit key space down to the valid range. The scure/starknet\n * library handles that with `grindKey`.\n *\n * @param privateKey - A 0x‐prefixed hex string (or hex without prefix).\n * @returns A 0x‐prefixed hex string suitable for Starknet usage.\n */\nexport function grindKey(privateKey: Hex): string {\n  return addHexPrefix(microGrindKey(privateKey))\n}\n\n/**\n * Creates a canonical integer from a name by hashing and truncating.\n * (Example utility that might be used to customize derivation paths, etc.)\n *\n * @param name - Some string (e.g. \"myaccount\", \"myviewkey\", etc.)\n * @returns A 31-bit number derived from the SHA-256 of `name`.\n */\nexport function pathHash(name: string): number {\n  const bigHash = BigInt.asUintN(\n    31,\n    BigInt(addHexPrefix(bytesToHex(sha256(name)))),\n  )\n  return Number(bigHash)\n}\n\n/**\n * Derive a Starknet \"spend\" private key from BIP-39 mnemonic, using\n * an HD derivation path.  This effectively gives you the primary\n * private key you can use for transactions/ownership (like `x`).\n *\n * @param args - Contains accountIndex, addressIndex, etc.\n * @param mnemonic - BIP-39 phrase (\"word word word ...\")\n * @returns A 0x‐prefixed hex string of the ground (spend) private key.\n */\nexport function deriveStarknetPrivateKey(\n  args: StarknetDerivationArgs,\n  mnemonic: string,\n): string {\n  const { accountIndex, addressIndex } = args\n\n  // Example derivation path: m/44'/9004'/account'/0/address\n  // (since Starknet uses coin_type=9004 typically)\n  const path = `m/${StarknetKeyConst.PURPOSE}'/${StarknetKeyConst.STARKNET_COIN_TYPE}'/${accountIndex}'/0/${addressIndex}`\n\n  // Using ethers.HDNodeWallet for the BIP-39 derivation:\n  const derivedWallet = ethers.HDNodeWallet.fromPhrase(\n    mnemonic,\n    undefined,\n    path,\n  )\n\n  // Now \"grind\" that private key for Starknet usage:\n  const groundKey = grindKey(derivedWallet.privateKey)\n\n  // getStarkKey(...) from scure returns a **public** key by default.\n  // If you only want the private key, just keep `groundKey`.\n  // But if you do want a consistent representation that is a \"private key\"\n  // for your usage, you can do:\n  return addHexPrefix(groundKey)\n}\n\n/**\n * Derive a Starknet public key from the private key.\n *\n * @param privateKey - a valid, ground Starknet private key (0x‐prefixed).\n * @returns A 0x‐prefixed hex public key on Starknet (typically 251 bits).\n */\nexport function getStarknetPublicKeyFromPrivate(\n  privateKey: string,\n  compressed = false,\n): string {\n  // scure/starknet's `getStarkKey()` returns a hex representation\n  // of the point's x‐coordinate, but you may also do a full \"point\".\n  if (compressed) {\n    //return getStarkKey(privateKey); // for just the x-coordinate\n    return getStarkKey(privateKey)\n  }\n  // Or, for the full public key:\n  const pubKeyBytes = ec.starkCurve.getPublicKey(privateKey, false)\n  return encode.addHexPrefix(encode.buf2hex(pubKeyBytes))\n}\n\n/**\n * Derive a \"spend\" key pair from a mnemonic phrase.\n */\nexport function deriveStarknetSpendKeyPair(\n  args: StarknetDerivationArgs,\n  mnemonic: string,\n  compressed = false,\n): {\n  privateSpendKey: string\n  publicSpendKey: string\n} {\n  const privateKey = deriveStarknetPrivateKey(args, mnemonic)\n  const publicKey = getStarknetPublicKeyFromPrivate(privateKey, compressed)\n  return {\n    privateSpendKey: privateKey,\n    publicSpendKey: publicKey,\n  }\n}\n\n/**\n * Derive a “view” keypair from the spend private key (Monero‐style),\n * i.e. privateViewKey = H(spendKey) mod curve_order\n * and publicViewKey = privateViewKey * G.\n *\n * This ensures the two keys are linked but distinct.\n *\n * @param spendPrivateKey - The main/spend key you got from `deriveStarknetPrivateKey()`.\n * @returns { privateViewKey, publicViewKey } as 0x‐prefixed hex strings\n */\nexport function deriveStarknetViewKeyPair(\n  spendPrivateKey: string,\n  compressed = false,\n): {\n  privateViewKey: string\n  publicViewKey: string\n} {\n  // 1. Compute a 256-bit hash of the spend key. Use starknetKeccak for consistency:\n  //  const spendKeyBN = BigInt(spendPrivateKey) // interpret as BigInt\n  // Convert to hex (without \"0x\" for the hashing step):\n  const spendKeyHexNo0x = spendPrivateKey.replace(/^0x/, \"\").toLowerCase()\n\n  // Hash the *raw hex* of spendKey:\n  const hashed = hash.starknetKeccak(spendKeyHexNo0x)\n\n  // 2. Take that BigInt mod Stark curve order:\n  const curveOrder = ec.starkCurve.CURVE.n\n  const privViewBN = BigInt(hashed) % curveOrder\n  const privateViewHex = `0x${privViewBN.toString(16)}`\n\n  // 3. Derive public view key:\n  const pubViewBytes = ec.starkCurve.getPublicKey(privateViewHex, false)\n  if (compressed) {\n    return {\n      privateViewKey: privateViewHex,\n      publicViewKey: getStarkKey(privateViewHex),\n    }\n  }\n  const publicViewHex = encode.addHexPrefix(encode.buf2hex(pubViewBytes))\n\n  return {\n    privateViewKey: privateViewHex,\n    publicViewKey: publicViewHex,\n  }\n}\n\n/**\n * Create spend and view key pairs from a mnemonic phrase.\n */\nexport function deriveStarknetKeyPairs(\n  args: StarknetDerivationArgs,\n  mnemonic: string,\n  compressed = false,\n): StarknetKeyPair {\n  const spendingKeyPair = deriveStarknetSpendKeyPair(args, mnemonic, compressed)\n  const viewingKeyPair = deriveStarknetViewKeyPair(\n    spendingKeyPair.privateSpendKey,\n    compressed,\n  )\n  return {\n    spendingKeyPair: {\n      privateSpendingKey: spendingKeyPair.privateSpendKey,\n      publicSpendingKey: spendingKeyPair.publicSpendKey,\n    },\n    viewingKeyPair: {\n      privateViewingKey: viewingKeyPair.privateViewKey,\n      publicViewingKey: viewingKeyPair.publicViewKey,\n    },\n  }\n}\n","import { CustomError } from \"ts-custom-error\"\n\nconst formatMessage = (detail?: string) => {\n  const messageDetail = detail ? `: ${detail}` : \"\"\n  return `Authentication failure${messageDetail}`\n}\n\nexport const formatErrorMessage = (reason: string, detail?: string) =>\n  reason + (detail ? ` (${detail})` : \"\")\n\ninterface ErrorLike {\n  message: string\n  stack: string\n}\n\ninterface WithInnerError {\n  innerError: string | Error\n}\n\n/**\n * Gets whether the given error has an innerError.\n *\n * @param error The error to be checked for.\n */\nconst isWithInnerError = (error: unknown): error is WithInnerError =>\n  error !== null &&\n  typeof error === \"object\" &&\n  \"innerError\" in (error as never)\n\n/**\n * This type check works as an \"error instanceof Error\" check, but it let pass also those objects\n * which implements the Error interface without inheriting from the same base class\n * (as the errors thrown by the fs package are)\n *\n * @param error the error object to evaluate\n * @returns whether the input error is or not an ErrorLike\n */\nconst isErrorLike = (error: unknown): error is ErrorLike => {\n  if (\n    !error ||\n    typeof error !== \"object\" ||\n    !(\"message\" in (error as never) && \"stack\" in (error as never))\n  )\n    return false\n\n  const { message, stack } = error as ErrorLike\n\n  return typeof message === \"string\" && typeof stack === \"string\"\n}\n\n/**\n * Strips the stack trace of all errors and their inner errors recursively.\n *\n * @param error The error to be stripped of its stack trace.\n */\nexport const stripStackTrace = (error: unknown) => {\n  if (!error) return\n\n  if (isErrorLike(error)) {\n    ;(error as Error).stack = \"\"\n  }\n\n  if (isWithInnerError(error)) {\n    stripStackTrace(error.innerError)\n  }\n}\n\nexport class ComposableError<InnerError = unknown> extends CustomError {\n  private static stackDelimiter = \"\\n    at \"\n\n  constructor(\n    message: string,\n    public innerError?: InnerError,\n  ) {\n    let firstLineOfInnerErrorStack = \"\"\n    let innerErrorStack: string[] = []\n\n    if (isErrorLike(innerError) && innerError.stack) {\n      const innerErrorStackPieces = innerError.stack.split(\n        ComposableError.stackDelimiter,\n      )\n      firstLineOfInnerErrorStack = innerErrorStackPieces.shift() || \"\"\n      innerErrorStack = innerErrorStackPieces\n\n      message = `${message} due to\\n ${firstLineOfInnerErrorStack}`\n    }\n\n    if (typeof innerError === \"string\")\n      message = `${message} due to\\n ${innerError}`\n\n    super(message)\n\n    if (!this.stack || innerErrorStack.length === 0) return\n\n    const [firstLineOfStack] = this.stack.split(ComposableError.stackDelimiter)\n\n    Object.defineProperty(this, \"stack\", {\n      configurable: true,\n      value: `${firstLineOfStack}${innerErrorStack.join(\n        ComposableError.stackDelimiter,\n      )}`,\n    })\n  }\n}\n\nexport class InvalidStringError<\n  InnerError = unknown,\n> extends ComposableError<InnerError> {\n  constructor(expectation: string, innerError?: InnerError) {\n    super(`Invalid string: \"${expectation}\"`, innerError)\n  }\n}\n\n/**\n * Represents an error that is thrown when a function is called with an invalid argument.\n */\nexport class InvalidArgumentError extends CustomError {\n  /**\n   * Initializes a new instance of the InvalidArgumentError class.\n   *\n   * @param argName The invalid argument name.\n   * @param message The error message.\n   */\n  public constructor(argName: string, message: string) {\n    super(`Invalid argument '${argName}': ${message}`)\n  }\n}\n\n/**\n * The error that is thrown when a method call is invalid for the object's current state.\n *\n * This error can be used in cases when the failure to invoke a method is caused by reasons\n * other than invalid arguments.\n */\nexport class InvalidStateError extends CustomError {\n  /**\n   * Initializes a new instance of the InvalidStateError class.\n   *\n   * @param message The error message.\n   */\n  public constructor(message: string) {\n    super(`Invalid state': ${message}`)\n  }\n}\n\nexport class AuthenticationError<\n  InnerError = unknown,\n> extends ComposableError<InnerError> {\n  constructor(detail?: string, innerError?: InnerError) {\n    super(formatMessage(detail), innerError)\n  }\n}\n","import { CustomError } from \"ts-custom-error\"\n\nexport class InvalidMnemonicError extends CustomError {\n  public constructor() {\n    super(\"Invalid Mnemonic\")\n  }\n}\n","export function getRealErrorMsg(err: unknown): string | undefined {\n  if (err instanceof Error) {\n    return err.message\n  }\n  if (typeof err === \"string\") {\n    return err\n  }\n  return String(err)\n}\n","import { wordlist } from \"@scure/bip39/wordlists/english\"\n\nimport { KeyAgentBase } from \"./KeyAgentBase\"\nimport * as errors from \"./errors\"\nimport {\n  type ChainDerivationArgs,\n  type GetPassphrase,\n  type KeyAgent,\n  KeyAgentType,\n  type SerializableInMemoryKeyAgentData,\n} from \"./types\"\nimport {\n  joinMnemonicWords,\n  mnemonicWordsToEncryptedSeed,\n  validateMnemonic,\n} from \"./util\"\n\nexport interface InMemoryKeyAgentProps\n  extends Omit<SerializableInMemoryKeyAgentData, \"__typename\"> {\n  getPassphrase: GetPassphrase\n  mnemonic: string\n}\n\nexport interface FromBip39MnemonicWordsProps {\n  mnemonicWords: string[]\n  mnemonic2ndFactorPassphrase?: string\n  getPassphrase: GetPassphrase\n}\n\nexport class InMemoryKeyAgent extends KeyAgentBase implements KeyAgent {\n  static async fromMnemonicWords({\n    getPassphrase,\n    mnemonicWords,\n    mnemonic2ndFactorPassphrase = \"\",\n  }: FromBip39MnemonicWordsProps): Promise<InMemoryKeyAgent> {\n    const mnemonic = joinMnemonicWords(mnemonicWords)\n    const validMnemonic = validateMnemonic(mnemonic, wordlist)\n    if (!validMnemonic) throw new errors.InvalidMnemonicError()\n\n    const passphrase = getPassphrase()\n    const encryptedSeedBytes = await mnemonicWordsToEncryptedSeed(\n      mnemonicWords,\n      passphrase,\n      mnemonic2ndFactorPassphrase,\n    )\n\n    return new InMemoryKeyAgent({\n      encryptedSeedBytes,\n      type: [], // to rename\n      id: \"\",\n      issuer: \"\",\n      issuanceDate: \"\",\n      credentialSubject: {\n        id: \"\",\n        contents: [],\n      },\n      getPassphrase,\n      mnemonic,\n    })\n  }\n\n  constructor({\n    getPassphrase,\n    mnemonic,\n    ...serializableData\n  }: InMemoryKeyAgentProps) {\n    super(\n      { ...serializableData, __typename: KeyAgentType.InMemory },\n      getPassphrase,\n      mnemonic,\n    )\n  }\n\n  async restoreKeyAgent(\n    args: ChainDerivationArgs,\n    getPassphrase: GetPassphrase,\n  ): Promise<InMemoryKeyAgent> {\n    await this.deriveCredentials(args, getPassphrase, false)\n    return this\n  }\n\n  getSeralizableData(): SerializableInMemoryKeyAgentData {\n    return {\n      ...this.serializableData,\n    }\n  }\n}\n","import { HDKey } from \"@scure/bip32\"\n\nimport { bytesToUtf8 } from \"@noble/ciphers/utils\"\nimport { utf8ToBytes } from \"@noble/hashes/utils\"\nimport { KeyDecryptor } from \"./KeyDecryptor\"\nimport {\n  type SignablePayload,\n  type StarknetKeyPair,\n  deriveStarknetKeyPairs,\n} from \"./chains/starknet\"\nimport { deriveCredential } from \"./chains/starknet/credential-derivation\"\nimport { SigningOperations } from \"./chains/starknet/signing-operations\"\nimport {\n  checkStealthOwnership,\n  createStealthOutput,\n} from \"./chains/starknet/stealth-derivation\"\nimport { emip3encrypt } from \"./emip3\"\nimport * as errors from \"./errors\"\nimport type {\n  ChainDerivationArgs,\n  ChainKeyPair,\n  ChainOperationArgs,\n  ChainSignatureResult,\n  GetPassphrase,\n} from \"./types\"\nimport type {\n  GroupedCredentials,\n  KeyAgent,\n  RecipientPublicKeys,\n  SerializableKeyAgentData,\n  StealthAddress,\n} from \"./types\"\n\nexport abstract class KeyAgentBase implements KeyAgent {\n  readonly serializableData: SerializableKeyAgentData\n  private keyDecryptor: KeyDecryptor\n  private mnemonic: string\n\n  get knownCredentials(): GroupedCredentials[] {\n    return this.serializableData.credentialSubject.contents\n  }\n  set knownCredentials(credentials: GroupedCredentials[]) {\n    this.serializableData.credentialSubject.contents = credentials\n  }\n\n  constructor(\n    serializableData: SerializableKeyAgentData,\n    getPassphrase: GetPassphrase,\n    mnemonic: string,\n  ) {\n    this.serializableData = serializableData\n    this.mnemonic = mnemonic\n    this.keyDecryptor = new KeyDecryptor(getPassphrase)\n  }\n\n  async decryptSeed(): Promise<Uint8Array> {\n    // TODO: add passphrase as an argument?\n    try {\n      return await this.keyDecryptor.decryptSeedBytes(this.serializableData)\n    } catch (error) {\n      throw new Error(`Failed to decrypt root private key: ${error}`)\n    }\n  }\n\n  async exportRootPrivateKey(): Promise<Uint8Array> {\n    // TODO: add passphrase as an argument?\n    try {\n      const decryptedSeedBytes = await this.decryptSeed()\n      const rootKey = HDKey.fromMasterSeed(decryptedSeedBytes)\n      return rootKey.privateKey ? rootKey.privateKey : new Uint8Array([])\n    } catch (error) {\n      throw new errors.AuthenticationError(\n        \"Failed to export root private key\",\n        error,\n      )\n    }\n  }\n\n  async deriveCredentials(\n    args: ChainDerivationArgs,\n    getPassphrase: GetPassphrase,\n    pure?: boolean,\n  ): Promise<GroupedCredentials> {\n    const passphrase = getPassphrase()\n\n    // check if the credential is already in the known credentials in the serializable data\n    const knownCredential =\n      this.serializableData.credentialSubject.contents.find(\n        (cred) => cred.accountIndex === args.accountIndex,\n      )\n    if (knownCredential) {\n      console.log(\"found a known credential\", knownCredential)\n      return knownCredential\n    }\n\n    const derivedKeyPairs = await this.deriveKeyPair(args, passphrase)\n\n    try {\n      const groupedCredential = deriveCredential(\n        args,\n        derivedKeyPairs.spendingKeyPair.publicSpendingKey,\n        derivedKeyPairs.spendingKeyPair.encryptedPrivateKeyBytes,\n        derivedKeyPairs.viewingKeyPair.publicViewingKey,\n        derivedKeyPairs.viewingKeyPair.encryptedPrivateKeyBytes,\n      )\n\n      if (!pure) {\n        this.serializableData.credentialSubject.contents = [\n          ...this.serializableData.credentialSubject.contents,\n          groupedCredential,\n        ]\n      }\n      return groupedCredential\n    } catch (error) {\n      console.error(error)\n      throw error\n    }\n  }\n\n  async deriveKeyPair(\n    args: ChainDerivationArgs,\n    passphrase: Uint8Array,\n  ): Promise<ChainKeyPair> {\n    // Generate the private key\n    let keypairs: StarknetKeyPair | Uint8Array | null\n    keypairs = this.#generateKeyPairsFromSeed(args)\n    // check if keypairs is StarknetKeyPair if not throw error\n    // Use something more specific:\n    if (\n      !keypairs ||\n      typeof keypairs !== \"object\" ||\n      !(\"spendingKeyPair\" in keypairs) ||\n      !(\"viewingKeyPair\" in keypairs)\n    ) {\n      throw new Error(\"Failed to generate key pairs\")\n    }\n    const encoder = new TextEncoder()\n    const encryptedSpendingKeyPrivateKeyBytes = await emip3encrypt(\n      encoder.encode(keypairs.spendingKeyPair.privateSpendingKey),\n      passphrase,\n    )\n    const encryptedViewingKeyPrivateKeyBytes = await emip3encrypt(\n      encoder.encode(keypairs.viewingKeyPair.privateViewingKey),\n      passphrase,\n    )\n\n    try {\n      const keyPairs = {\n        spendingKeyPair: {\n          publicSpendingKey: keypairs.spendingKeyPair.publicSpendingKey,\n          encryptedPrivateKeyBytes: encryptedSpendingKeyPrivateKeyBytes,\n        },\n        viewingKeyPair: {\n          publicViewingKey: keypairs.viewingKeyPair.publicViewingKey,\n          encryptedPrivateKeyBytes: encryptedViewingKeyPrivateKeyBytes,\n        },\n      }\n      // Overwrite and nullify the privateKey\n      keypairs = utf8ToBytes(\"0\".repeat(50))\n      keypairs = null\n\n      return keyPairs\n    } catch (error) {\n      // Overwrite and nullify the privateKey\n      if (keypairs) {\n        keypairs = utf8ToBytes(\"0\".repeat(50))\n        keypairs = null\n      }\n      console.error(error)\n      throw error\n    }\n  }\n\n  deriveStealthAddress(\n    recipientPublicKeys: RecipientPublicKeys,\n  ): StealthAddress {\n    return createStealthOutput(\n      recipientPublicKeys.recipientPubSpendKey,\n      recipientPublicKeys.recipientPubViewKey,\n    )\n  }\n\n  async stealthOwnershipCheck(\n    ephemeralPublicKey: string,\n    stealthAddress: string,\n    groupedCredential: GroupedCredentials,\n  ): Promise<boolean> {\n    // Decrypt the private view key (which was encrypted)\n    const viewingKeyBytes = new Uint8Array(\n      groupedCredential.viewingKey.encryptedPrivateKeyBytes,\n    )\n    const decryptedPrivateViewKeyBytes =\n      await this.keyDecryptor.decryptChildPrivateKey(viewingKeyBytes)\n    // Decode to a string (the originally encrypted hex string)\n    const privateViewKey = bytesToUtf8(decryptedPrivateViewKeyBytes)\n\n    // Use the public spending key directly (it was stored in plain text)\n    const publicSpendKey = groupedCredential.spendingKey.publicSpendingKey\n\n    // Ensure both keys have the proper \"0x\" prefix\n    const formattedPrivateViewKey = privateViewKey.startsWith(\"0x\")\n      ? privateViewKey\n      : `0x${privateViewKey}`\n    const formattedPublicSpendKey = publicSpendKey.startsWith(\"0x\")\n      ? publicSpendKey\n      : `0x${publicSpendKey}`\n\n    return checkStealthOwnership(\n      formattedPrivateViewKey, // recipientPrivateViewKey (hex)\n      formattedPublicSpendKey, // recipientPublicSpendKey (hex)\n      ephemeralPublicKey, // ephemeralPublicKey (hex)\n      stealthAddress, // stealthAddress (hex)\n    )\n  }\n\n  async sign<T extends GroupedCredentials>(\n    payload: T,\n    signable: SignablePayload,\n    args: ChainOperationArgs,\n  ): Promise<ChainSignatureResult> {\n    const decryptedKeyBytes = await this.keyDecryptor.decryptChildPrivateKey(\n      new Uint8Array(\n        Object.values(payload.spendingKey.encryptedPrivateKeyBytes),\n      ),\n    )\n\n    const privateKey: string | null = bytesToUtf8(decryptedKeyBytes)\n    let result\n\n    try {\n      result = SigningOperations(args, privateKey, signable as SignablePayload)\n    } catch (error) {\n      console.error(error)\n      throw error\n    }\n\n    return result\n  }\n\n  #generateKeyPairsFromSeed<T extends ChainDerivationArgs>(\n    args: T,\n  ): StarknetKeyPair {\n    return deriveStarknetKeyPairs(args, this.mnemonic, false)\n  }\n}\n","import { chacha20poly1305 } from \"@noble/ciphers/chacha\"\nimport { randomBytes } from \"@noble/ciphers/webcrypto\"\nimport { pbkdf2Async } from \"@noble/hashes/pbkdf2\"\nimport { sha512 } from \"@noble/hashes/sha512\"\nimport { concatBytes } from \"@noble/hashes/utils\"\n\nconst KEY_LENGTH = 32\nconst NONCE_LENGTH = 12\nconst PBKDF2_ITERATIONS = 210_000\nconst SALT_LENGTH = 32\n\nexport const createPbkdf2Key = async (\n  passphrase: Uint8Array,\n  salt: Uint8Array | Uint16Array,\n) => {\n  const saltAsUint8Array = new Uint8Array(salt)\n  const derivedKey = await pbkdf2Async(sha512, passphrase, saltAsUint8Array, {\n    c: PBKDF2_ITERATIONS,\n    dkLen: KEY_LENGTH,\n  })\n  return derivedKey\n}\n\nexport const emip3encrypt = async (\n  data: Uint8Array,\n  passphrase: Uint8Array,\n): Promise<Uint8Array> => {\n  const salt = randomBytes(SALT_LENGTH)\n  const key = await createPbkdf2Key(passphrase, salt)\n  const nonce = randomBytes(NONCE_LENGTH)\n  const cipher = chacha20poly1305(key, nonce)\n  const encrypted = cipher.encrypt(data)\n  return concatBytes(salt, nonce, encrypted)\n}\n\nexport const emip3decrypt = async (\n  encrypted: Uint8Array,\n  passphrase: Uint8Array,\n): Promise<Uint8Array> => {\n  const salt = encrypted.slice(0, SALT_LENGTH)\n  const nonce = encrypted.slice(SALT_LENGTH, SALT_LENGTH + NONCE_LENGTH)\n  const data = encrypted.slice(SALT_LENGTH + NONCE_LENGTH)\n  const key = await createPbkdf2Key(passphrase, salt)\n  const decipher = chacha20poly1305(key, nonce)\n  return decipher.decrypt(data)\n}\n","import { emip3decrypt } from \"./emip3\"\nimport * as errors from \"./errors\"\nimport type {\n  EncryptedKeyPropertyName,\n  GetPassphrase,\n  SerializableKeyAgentData,\n} from \"./types\"\n\nexport class KeyDecryptor {\n  #getPassphrase: (noCache?: true) => Uint8Array\n\n  constructor(getPassphrase: GetPassphrase) {\n    this.#getPassphrase = getPassphrase\n  }\n\n  async decryptChildPrivateKey(\n    encryptedPrivateKeyBytes: Uint8Array,\n    noCache?: true,\n  ): Promise<Uint8Array> {\n    const passphrase = this.#getPassphrase(noCache)\n    let decryptedKeyBytes: Uint8Array\n    try {\n      decryptedKeyBytes = await emip3decrypt(\n        encryptedPrivateKeyBytes,\n        passphrase,\n      )\n    } catch (error) {\n      throw new errors.AuthenticationError(\n        \"Failed to decrypt child private key\",\n        error,\n      )\n    }\n    return decryptedKeyBytes\n  }\n\n  decryptSeedBytes(serializableData: SerializableKeyAgentData, noCache?: true) {\n    return this.decryptSeed(\n      \"encryptedSeedBytes\",\n      serializableData,\n      \"Failed to decrypt seed bytes\",\n      noCache,\n    )\n  }\n\n  private async decryptSeed(\n    keyPropertyName: EncryptedKeyPropertyName,\n    serializableData: SerializableKeyAgentData,\n    errorMessage: string,\n    noCache?: true,\n  ) {\n    const passphrase = this.#getPassphrase(noCache)\n    let decryptedKeyBytes: Uint8Array\n    try {\n      decryptedKeyBytes = await emip3decrypt(\n        new Uint8Array(serializableData[keyPropertyName]),\n        passphrase,\n      )\n    } catch (error) {\n      throw new errors.AuthenticationError(errorMessage, error)\n    }\n    return decryptedKeyBytes\n  }\n}\n","import type {\n  StarknetDerivationArgs,\n  StarknetGroupedCredentials,\n} from \"./types\"\n\nexport function deriveCredential(\n  args: StarknetDerivationArgs,\n  spendingPublicKey: string,\n  spendingKeyEncryptedPrivateKeyBytes: Uint8Array,\n  viewingPublicKey: string,\n  viewingKeyEncryptedPrivateKeyBytes: Uint8Array,\n): StarknetGroupedCredentials {\n  return {\n    \"@context\": [\"https://w3id.org/wallet/v1\"],\n    id: `did:strk:${spendingPublicKey}`,\n    type: \"Starknet\",\n    controller: `did:strk:${spendingPublicKey}`,\n    name: \"Starknet Key Pair\",\n    description: \"My Starknet Keys.\",\n    addressIndex: args.addressIndex,\n    accountIndex: args.accountIndex,\n    spendingKey: {\n      publicSpendingKey: spendingPublicKey,\n      encryptedPrivateKeyBytes: spendingKeyEncryptedPrivateKeyBytes,\n    },\n    viewingKey: {\n      publicViewingKey: viewingPublicKey,\n      encryptedPrivateKeyBytes: viewingKeyEncryptedPrivateKeyBytes,\n    },\n  }\n}\n","import {\n  type DeclareSignerDetails,\n  type DeployAccountSignerDetails,\n  Signer,\n  type TypedData,\n} from \"starknet\"\nimport * as errors from \"../../errors\"\nimport type { ChainOperationArgs } from \"../../types\"\nimport type { SignablePayload, SignatureResult } from \"./types\"\n\n/**\n * SigningOperations is a wrapper around the starknet-js `Signer` class.\n *\n * Based on the provided `args.operation`, it will call one of:\n * - signMessage(TypedData, accountAddress)\n * - signTransaction(Call[], InvocationsSignerDetails)\n * - signDeployAccountTransaction(DeployAccountSignerDetails)\n * - signDeclareTransaction(DeclareSignerDetails)\n * - signRaw(msgHash)\n *\n * @param args        - Contains which operation to perform, plus any needed fields\n * @param privateKey  - The Starknet private key (0x or hex string) used for signing\n * @param payload     - The data you want to sign (could be typed data, calls, etc.)\n * @returns           A Promise that resolves to the resulting signature (string[])\n */\nexport async function SigningOperations<T extends SignablePayload>(\n  args: ChainOperationArgs,\n  privateKey: string,\n  payload: T,\n): Promise<SignatureResult> {\n  // Create the underlying starknet-js Signer\n  const signer = new Signer(privateKey)\n\n  try {\n    let signature: SignatureResult\n\n    switch (args.operation) {\n      /**\n       * sign_message => expects `payload` to be TypedData.\n       * The starknet-js Signer also needs an `accountAddress`.\n       */\n      case \"sign_message\": {\n        if (!args.accountAddress) {\n          throw new Error(\n            \"Missing 'accountAddress' for 'sign_message' operation.\",\n          )\n        }\n        // If your payload can be raw strings or typed data,\n        // you might want to check if it's actually typed data:\n        // if (!isTypedData(payload)) { ... }\n\n        signature = await signer.signMessage(\n          payload as TypedData,\n          args.accountAddress,\n        )\n        break\n      }\n\n      /**\n       * sign_transaction => expects `payload` to be Call[]\n       * (an array of calls) and `args.transactionDetails`\n       * to be an object like `InvocationsSignerDetails`.\n       */\n      case \"sign_transaction\": {\n        if (!Array.isArray(payload)) {\n          throw new Error(\n            \"For 'sign_transaction', payload must be an array of Calls.\",\n          )\n        }\n        if (!args.transactionDetails) {\n          throw new Error(\n            \"Missing 'transactionDetails' for 'sign_transaction' operation.\",\n          )\n        }\n\n        // We cast transactionDetails to the appropriate signer details interface\n        // (InvocationsSignerDetails, V2InvocationsSignerDetails, etc.)\n        signature = await signer.signTransaction(\n          payload,\n          args.transactionDetails,\n        )\n        break\n      }\n\n      /**\n       * sign_deploy_account => expects `payload` to be DeployAccountSignerDetails\n       */\n      case \"sign_deploy_account\": {\n        // We cast the payload to DeployAccountSignerDetails\n        // If you want stronger type checks, you'd do a runtime validation here\n        signature = await signer.signDeployAccountTransaction(\n          payload as DeployAccountSignerDetails,\n        )\n        break\n      }\n\n      /**\n       * sign_declare => expects `payload` to be DeclareSignerDetails\n       */\n      case \"sign_declare\": {\n        // Similarly, cast the payload to DeclareSignerDetails\n        signature = await signer.signDeclareTransaction(\n          payload as unknown as DeclareSignerDetails,\n        )\n        break\n      }\n\n      /**\n       * sign_raw => expects `payload` to be a string (the msgHash to sign)\n       * this is a protected method in starknet-js, so we need to use a different approach\n       */\n      /*case \"sign_raw\": {\n        if (typeof payload !== \"string\") {\n          throw new Error(\"For 'sign_raw', payload must be a string msgHash.\")\n        }\n        signature = await signer.signRaw(payload)\n        // (signRaw is protected in source, but if you've exposed it or\n        //  changed your local Signer to be public, you can call it.\n        //  Otherwise you might replicate signRaw(...) logic manually.)\n        break\n      }*/\n\n      default: {\n        throw new Error(`Unsupported private key operation: ${args.operation}`)\n      }\n    }\n\n    return signature\n  } catch (err) {\n    const errorMessage = errors.getRealErrorMsg(err) || \"Signing action failed.\"\n    throw new Error(errorMessage)\n  }\n}\n","import { randomBytes } from \"node:crypto\"\nimport { bytesToHex } from \"@noble/curves/abstract/utils\"\nimport { ec, encode, hash, num } from \"starknet\"\n\n/**\n * Generate a fresh ephemeral private scalar using secure randomness.\n */\nexport function generateEphemeralScalar(): bigint {\n  const raw = randomBytes(32) // 32 bytes\n  // The curve's private keys must be in [1..curve_order-1]\n  // but for simplicity, we interpret 32 random bytes as a BigInt\n  // Then we mod it by curve order to get a valid scalar on StarkCurve\n  const curveOrder = ec.starkCurve.CURVE.n\n  return BigInt(`0x${bytesToHex(Uint8Array.from(raw))}`) % curveOrder\n}\n\n/**\n * Convert a private key (bigint or hex) to a public key on Starknet curve.\n */\nexport function starknetPublicKeyFromPrivateKey(privKeyHex: string): string {\n  // ec.getPublicKey returns a Uint8Array. We'll encode it in hex\n  const pubKeyBytes = ec.starkCurve.getPublicKey(privKeyHex, false)\n  return encode.buf2hex(pubKeyBytes)\n}\n\n/**\n * Create a stealth address given the recipient's public spend/view keys (X, Y).\n *\n * @param recipientPubSpendKey The recipient's public spend key (hex, 0x‐prefixed).\n * @param recipientPubViewKey  The recipient's public view key (hex, 0x‐prefixed).\n * @returns An object containing:\n *   - ephemeralPrivateScalar  The sender's ephemeral private scalar `r` (for demonstration)\n *   - ephemeralPublicKey      R = r * G\n *   - stealthAddress          P = X + k*G where k = Hash(r * Y)\n */\nexport function createStealthOutput(\n  recipientPubSpendKey: string,\n  recipientPubViewKey: string,\n) {\n  // 1. Sender picks ephemeral r\n  const r = generateEphemeralScalar()\n\n  // 2. R = r * G\n  const R = ec.starkCurve.getPublicKey(num.toHex(r), false)\n  const Rhex = encode.buf2hex(R)\n\n  // 3. k = Hash(r * Y)\n  // Convert Y from hex to a point:\n  const Ypoint = ec.starkCurve.ProjectivePoint.fromHex(\n    recipientPubViewKey.replace(/^0x/, \"\"),\n  )\n  const rTimesY = Ypoint.multiply(r) // big point\n  // We do a Starknet keccak, for instance:\n  const kBigInt = hash.starknetKeccak(encode.buf2hex(rTimesY.toRawBytes(true)))\n\n  // 4. k is a scalar, so we might take mod n:\n  const kMod = BigInt(kBigInt) % ec.starkCurve.CURVE.n\n\n  // 5. P = X + k*G\n  //    But note: X is a point, so we do Xpoint + (k * G).\n  const Xpoint = ec.starkCurve.ProjectivePoint.fromHex(\n    recipientPubSpendKey.replace(/^0x/, \"\"),\n  )\n  const stealthPoint =\n    ec.starkCurve.ProjectivePoint.BASE.multiply(kMod).add(Xpoint)\n  const stealthHex = encode.buf2hex(stealthPoint.toRawBytes(false))\n\n  return {\n    ephemeralPrivateScalar: `0x${r.toString(16)}`,\n    ephemeralPublicKey: encode.addHexPrefix(Rhex),\n    stealthAddress: encode.addHexPrefix(stealthHex),\n  }\n}\n\n/**\n * Check if a stealth output belongs to the recipient:\n * @param recipientPrivateViewKey y (hex)\n * @param recipientPublicSpendKey X (hex)\n * @param ephemeralPublicKey R (hex)\n * @param stealthAddress P (hex)\n *\n * Steps:\n *   k' = Hash(y * R)\n *   Check if P == X + k'*G\n */\nexport function checkStealthOwnership(\n  recipientPrivateViewKey: string,\n  recipientPublicSpendKey: string,\n  ephemeralPublicKey: string,\n  stealthAddress: string,\n): boolean {\n  // Convert ephemeral R to point:\n  const Rpoint = ec.starkCurve.ProjectivePoint.fromHex(\n    ephemeralPublicKey.replace(/^0x/, \"\"),\n  )\n  // y is the private view key:\n  const yBN = BigInt(recipientPrivateViewKey)\n  const yTimesR = Rpoint.multiply(yBN)\n\n  // k' = starknetKeccak(yTimesR)\n  const kPrimeBigInt = hash.starknetKeccak(\n    encode.buf2hex(yTimesR.toRawBytes(true)),\n  )\n  const kPrime = BigInt(kPrimeBigInt) % ec.starkCurve.CURVE.n\n\n  // Recompute P' = X + k'*G\n  const Xpoint = ec.starkCurve.ProjectivePoint.fromHex(\n    recipientPublicSpendKey.replace(/^0x/, \"\"),\n  )\n  const computedStealthPoint =\n    ec.starkCurve.ProjectivePoint.BASE.multiply(kPrime).add(Xpoint)\n  const computedStealthHex = encode.buf2hex(\n    computedStealthPoint.toRawBytes(false),\n  )\n\n  // Compare with the provided stealthAddress\n  // For safety, do a case-insensitive check or normalize to lowerCase\n  return (\n    stealthAddress.toLowerCase() === `0x${computedStealthHex}`.toLowerCase()\n  )\n}\n","import type {\n  SignablePayload,\n  SignatureResult,\n  StarknetDerivationArgs,\n  StarknetGroupedCredentials,\n} from \"./chains/starknet\"\n\nexport type PayloadTypes = \"transaction\" | \"message\" | \"fields\"\n\nexport interface Result<T> {\n  success: boolean\n  data?: T\n  error?: string\n}\n\nexport type EncryptedKeyPropertyName = \"encryptedSeedBytes\"\n\nexport enum KeyAgentType {\n  InMemory = \"InMemory\",\n  Session = \"Sesssion\",\n  Ledger = \"Ledger\",\n}\n\nexport interface SerializableInMemoryKeyAgentData {\n  __typename: KeyAgentType.InMemory\n  encryptedSeedBytes: Uint8Array\n  type: string[]\n  id: string\n  issuer: string\n  issuanceDate: string\n  credentialSubject: {\n    id: string\n    contents: GroupedCredentials[]\n  }\n}\n\nexport type SerializableKeyAgentData = SerializableInMemoryKeyAgentData\nexport type SerializableSessionKeyAgentData = {\n  __typename: KeyAgentType.Session\n  type: string[]\n  id: string\n  issuer: string\n  issuanceDate: string\n  credentialSubject: {\n    id: string\n    contents: GroupedCredentials[]\n  }\n}\nexport type GroupedCredentials = StarknetGroupedCredentials\n\nexport type CredentialMatcher<T extends ChainDerivationArgs> = (\n  credential: GroupedCredentials,\n  args: T,\n) => boolean\n\n// other new ones that work\nexport interface KeyPairDerivationOperations<T> {\n  derivePublicKey: (privateKey: Uint8Array) => Promise<string>\n  derivePrivateKey: (\n    decryptedSeedBytes: Uint8Array,\n    args: T,\n  ) => Promise<Uint8Array>\n}\n\nexport type ChainAddress = string\n\n/**\n * @returns passphrase used to decrypt private keys\n */\nexport type GetPassphrase = (noCache?: boolean) => Uint8Array\n\nexport interface AccountKeyDerivationPath {\n  account_ix: number\n}\nexport interface AddressKeyDerivationPath {\n  address_ix: number\n}\n\nexport type RecipientPublicKeys = {\n  recipientPubSpendKey: string\n  recipientPubViewKey: string\n}\n\nexport type StealthAddress = {\n  ephemeralPublicKey: string\n  stealthAddress: string\n}\n\nexport interface KeyAgent {\n  get serializableData(): SerializableKeyAgentData\n  get knownCredentials(): GroupedCredentials[]\n  set knownCredentials(credentials: GroupedCredentials[])\n  /**\n   * generic sign\n   */\n  sign<T extends GroupedCredentials>(\n    payload: T,\n    signable: ChainSignablePayload,\n    args: ChainOperationArgs,\n    getPassphrase: GetPassphrase,\n  ): Promise<ChainSignatureResult>\n\n  deriveKeyPair(\n    args: ChainDerivationArgs,\n    passphrase: Uint8Array,\n  ): Promise<ChainKeyPair>\n\n  deriveCredentials(\n    args: ChainDerivationArgs,\n    getPassphrase: GetPassphrase,\n    pure?: boolean,\n  ): Promise<GroupedCredentials>\n\n  deriveStealthAddress(recipientPublicKeys: RecipientPublicKeys): StealthAddress\n\n  stealthOwnershipCheck(\n    ephemeralPublicKey: string,\n    stealthAddress: string,\n    groupedCredential: GroupedCredentials,\n  ): Promise<boolean>\n\n  exportRootPrivateKey(getPassphrase: GetPassphrase): Promise<Uint8Array>\n\n  decryptSeed(getPassphrase: GetPassphrase): Promise<Uint8Array>\n}\n\nexport type ChainDerivationArgs = StarknetDerivationArgs\n\n/**\n * Arguments indicating which operation we want to perform, plus any\n * special fields needed. For example, `sign_message` needs an\n * `accountAddress`; `sign_transaction` needs invocation details, etc.\n */\nexport type ChainOperationArgs = {\n  operation:\n    | \"sign_message\"\n    | \"sign_transaction\"\n    | \"sign_deploy_account\"\n    | \"sign_declare\"\n    | \"sign_raw\"\n  /**\n   * The Starknet account address used by `signMessage()`.\n   * Not always needed for other operations, so it's optional.\n   */\n  accountAddress?: string\n  /**\n   * Additional details for transaction signing, declare, etc.\n   * For example, if you want to call `signTransaction(...)`,\n   * you can store an object of type `InvocationsSignerDetails` here.\n   */\n  transactionDetails?: any\n}\n\nexport interface ChainSpecificPayload {\n  network: any\n  derivePublicKey(\n    privateKey: ChainPrivateKey,\n    args: ChainDerivationArgs,\n  ): Promise<ChainPublicKey>\n  derivePrivateKey(\n    decryptedSeedBytes: Uint8Array,\n    args: ChainDerivationArgs,\n  ): Promise<ChainPrivateKey>\n}\n\nexport type ChainPublicKey = string\n\nexport type ChainSignatureResult = SignatureResult\n\nexport type ChainPrivateKey = Uint8Array\n\nexport type ChainKeyPair = {\n  spendingKeyPair: {\n    publicSpendingKey: string\n    encryptedPrivateKeyBytes: Uint8Array\n  }\n  viewingKeyPair: {\n    publicViewingKey: string\n    encryptedPrivateKeyBytes: Uint8Array\n  }\n}\n\nexport type ChainSigningFunction = (\n  args: ChainOperationArgs, // TODO: chain\n  privateKey: ChainPrivateKey,\n) => Promise<ChainSignatureResult>\n\nexport type ChainSignablePayload = SignablePayload\n\nexport enum PathLevelIndexes {\n  /**\n   * Index of the PURPOSE level in a BIP44 path\n   */\n  PURPOSE = 0,\n\n  /**\n   * Index of the COIN_TYPE level in a BIP44 path\n   */\n  COIN_TYPE = 1,\n\n  /**\n   * Index of the ACCOUNT level in a BIP44 path\n   */\n  ACCOUNT = 2,\n\n  /**\n   * Index of the CHANGE level in a BIP44 path\n   */\n  CHANGE = 3,\n\n  /**\n   * Index of the INDEX level in a BIP44 path\n   */\n  INDEX = 4,\n}\n","import * as bip39 from \"@scure/bip39\"\nimport { wordlist } from \"@scure/bip39/wordlists/english\"\n\nimport { emip3encrypt } from \"../emip3\"\n\n/**\n * A wrapper around the bip39 package function, with default strength applied to produce 24 words\n */\nexport const mnemonicToWords = (mnemonic: string) => mnemonic.split(\" \")\nexport const generateMnemonicWords = (strength = 256) =>\n  mnemonicToWords(bip39.generateMnemonic(wordlist, strength))\nexport const joinMnemonicWords = (mnenomic: string[]) => mnenomic.join(\" \")\nexport const entropyToMnemonicWords = (entropy: Uint8Array) =>\n  mnemonicToWords(bip39.entropyToMnemonic(entropy, wordlist))\nexport const mnemonicWordsToEntropy = (mnenonic: string[]) =>\n  bip39.mnemonicToEntropy(joinMnemonicWords(mnenonic), wordlist)\nexport const mnemonicToSeed = (mnemonic: string[], passphrase?: string) =>\n  bip39.mnemonicToSeedSync(joinMnemonicWords(mnemonic), passphrase)\nexport const mnemonicToSeedSync = (mnemonic: string, passphrase?: string) =>\n  bip39.mnemonicToSeedSync(mnemonic, passphrase)\n/**\n * A wrapper around the bip39 package function\n */\nexport const validateMnemonic = bip39.validateMnemonic\n\n/**\n *  A wrapper to produce a root from entropy\n */\nexport const entropyToSeed = (entropy: Uint8Array, passphrase?: string) => {\n  // Convert entropy to mnemonic words\n  const mnemonicWords = entropyToMnemonicWords(entropy)\n  // Get seed from mnemonic words plus the passphrase\n  const seed = mnemonicToSeed(mnemonicWords, passphrase)\n  // Get root key from seed\n  //const root = bip32.HDKey.fromMasterSeed(seed)\n  // Return unencrypted root key bytes\n  return seed //root.privateKey ? root.privateKey : Uint8Array\n}\n\n/**\n * A wrapper to produce an encrypted seed\n */\nexport const mnemonicWordsToEncryptedSeed = async (\n  mnemonicWords: string[],\n  passphrase: Uint8Array,\n  mnemonic2ndFactorPassphrase: string,\n) => {\n  // get seed from mnemonic\n  const seed = mnemonicToSeed(mnemonicWords, mnemonic2ndFactorPassphrase)\n  // encrypt seed\n  const encryptedSeed = await emip3encrypt(seed, passphrase)\n\n  return encryptedSeed\n}\n\nexport { wordlist }\n"],"mappings":"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","names":["StarknetKeyConst","CustomError","wordlist","randomBytes","ec","encode","hash","randomBytes","ec","encode","hash","KeyAgentType","PathLevelIndexes","mnemonicToSeedSync","validateMnemonic","validateMnemonic","wordlist"]}